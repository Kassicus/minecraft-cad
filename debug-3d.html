<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Debug - MinecraftCAD</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #1e3a5f;
            color: #e8f4f8;
        }
        
        .debug-container {
            max-width: 1000px;
            margin: 0 auto;
        }
        
        .debug-info {
            background: #122032;
            padding: 15px;
            margin-bottom: 20px;
            border: 1px solid #64b5f6;
        }
        
        .canvas-container {
            width: 800px;
            height: 600px;
            border: 2px solid #64b5f6;
            background: #0a1420;
            margin: 0 auto;
            position: relative;
        }
        
        #debug-canvas {
            width: 100%;
            height: 100%;
            display: block;
        }
        
        .controls {
            margin-top: 20px;
            text-align: center;
        }
        
        .btn {
            background: transparent;
            border: 1px solid #64b5f6;
            color: #e8f4f8;
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: inherit;
        }
        
        .btn:hover {
            background: rgba(100, 181, 246, 0.1);
        }
        
        .status {
            margin-top: 20px;
            padding: 10px;
            background: rgba(100, 181, 246, 0.1);
            border: 1px solid #64b5f6;
        }
        
        .error {
            color: #ff5555;
        }
        
        .success {
            color: #50fa7b;
        }
    </style>
</head>
<body>
    <div class="debug-container">
        <h1>3D Renderer Debug</h1>
        
        <div class="debug-info">
            <h3>Debug Information:</h3>
            <div id="debug-output"></div>
        </div>
        
        <div class="canvas-container">
            <canvas id="debug-canvas"></canvas>
        </div>
        
        <div class="controls">
            <button class="btn" onclick="testThreeJS()">Test Three.js</button>
            <button class="btn" onclick="testRenderer()">Test Renderer</button>
            <button class="btn" onclick="addTestBlocks()">Add Test Blocks</button>
            <button class="btn" onclick="resetCamera()">Reset Camera</button>
        </div>
        
        <div class="status" id="status"></div>
    </div>

    <!-- Three.js ES Module Setup -->
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.158.0/examples/jsm/"
        }
    }
    </script>
    <script type="module">
        // Load Three.js and OrbitControls as ES modules
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        
        // Make them available globally for our existing code
        window.THREE = THREE;
        window.OrbitControls = OrbitControls;
        
        console.log('Three.js and OrbitControls loaded as ES modules');
        console.log('THREE.REVISION:', THREE.REVISION);
        
        // Dispatch a custom event to notify when Three.js is ready
        window.dispatchEvent(new CustomEvent('threejs-loaded'));
    </script>
    
    <script>
        let scene, camera, renderer, controls;
        let debugOutput = document.getElementById('debug-output');
        let statusDiv = document.getElementById('status');
        
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const className = type === 'error' ? 'error' : type === 'success' ? 'success' : '';
            debugOutput.innerHTML += `<div class="${className}">[${timestamp}] ${message}</div>`;
            debugOutput.scrollTop = debugOutput.scrollHeight;
        }
        
        function setStatus(message, type = 'info') {
            statusDiv.innerHTML = message;
            statusDiv.className = `status ${type}`;
        }
        
        function testThreeJS() {
            log('Testing Three.js availability...');
            
            if (typeof THREE === 'undefined') {
                log('❌ THREE is not defined - waiting for ES modules...', 'error');
                setStatus('Waiting for Three.js ES modules to load...', 'error');
                
                // Wait for the threejs-loaded event
                window.addEventListener('threejs-loaded', () => {
                    log('✅ THREE loaded via ES modules', 'success');
                    testThreeJS(); // Retry the test
                }, { once: true });
                return false;
            }
            
            log('✅ THREE is available', 'success');
            log(`THREE.REVISION: ${THREE.REVISION}`);
            
            if (typeof OrbitControls !== 'undefined') {
                log('✅ OrbitControls available', 'success');
            } else {
                log('⚠️ OrbitControls not available', 'error');
            }
            
            setStatus('Three.js loaded successfully', 'success');
            return true;
        }
        
        function testRenderer() {
            if (!testThreeJS()) return;
            
            log('Initializing 3D renderer...');
            
            try {
                const canvas = document.getElementById('debug-canvas');
                
                // Scene
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0x0a1420);
                
                // Camera
                const aspect = canvas.clientWidth / canvas.clientHeight;
                camera = new THREE.PerspectiveCamera(75, aspect, 0.1, 1000);
                camera.position.set(10, 10, 10);
                
                // Renderer
                renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true });
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                
                // Lighting
                const ambientLight = new THREE.AmbientLight(0x64b5f6, 0.6);
                scene.add(ambientLight);
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
                directionalLight.position.set(10, 10, 5);
                scene.add(directionalLight);
                
                // Controls
                if (typeof OrbitControls !== 'undefined') {
                    controls = new OrbitControls(camera, canvas);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    log('✅ OrbitControls initialized', 'success');
                } else {
                    log('⚠️ Using basic controls', 'error');
                }
                
                // Test cube
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshLambertMaterial({ color: 0x666666 });
                const cube = new THREE.Mesh(geometry, material);
                scene.add(cube);
                
                // Start render loop
                function animate() {
                    requestAnimationFrame(animate);
                    
                    if (controls) {
                        controls.update();
                    }
                    
                    renderer.render(scene, camera);
                }
                animate();
                
                log('✅ 3D renderer initialized successfully', 'success');
                setStatus('3D renderer working', 'success');
                
            } catch (error) {
                log(`❌ Renderer initialization failed: ${error.message}`, 'error');
                setStatus('3D renderer failed', 'error');
            }
        }
        
        function addTestBlocks() {
            if (!scene) {
                log('❌ Scene not initialized', 'error');
                return;
            }
            
            log('Adding test blocks...');
            
            // Clear existing blocks
            const blocksToRemove = [];
            scene.traverse((child) => {
                if (child.userData.isBlock) {
                    blocksToRemove.push(child);
                }
            });
            blocksToRemove.forEach(block => scene.remove(block));
            
            // Add test blocks
            const geometry = new THREE.BoxGeometry(1, 1, 1);
            const materials = [
                new THREE.MeshLambertMaterial({ color: 0x666666 }),
                new THREE.MeshLambertMaterial({ color: 0x888888 }),
                new THREE.MeshLambertMaterial({ color: 0x444444 }),
                new THREE.MeshLambertMaterial({ color: 0x555555 }),
                new THREE.MeshLambertMaterial({ color: 0x777777 })
            ];
            
            for (let x = 0; x < 5; x++) {
                for (let z = 0; z < 5; z++) {
                    const cube = new THREE.Mesh(geometry, materials[x % materials.length]);
                    cube.position.set(x - 2, 0, z - 2);
                    cube.userData.isBlock = true;
                    scene.add(cube);
                }
            }
            
            log('✅ Test blocks added', 'success');
            setStatus('Test blocks added to scene', 'success');
        }
        
        function resetCamera() {
            if (!camera) {
                log('❌ Camera not initialized', 'error');
                return;
            }
            
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);
            
            if (controls) {
                controls.target.set(0, 0, 0);
                controls.update();
            }
            
            log('✅ Camera reset', 'success');
            setStatus('Camera position reset', 'success');
        }
        
        // Auto-test on load
        window.addEventListener('load', () => {
            setTimeout(() => {
                testThreeJS();
            }, 100);
        });
        
        // Handle resize
        window.addEventListener('resize', () => {
            if (camera && renderer) {
                const canvas = document.getElementById('debug-canvas');
                const aspect = canvas.clientWidth / canvas.clientHeight;
                camera.aspect = aspect;
                camera.updateProjectionMatrix();
                renderer.setSize(canvas.clientWidth, canvas.clientHeight);
            }
        });
    </script>
</body>
</html>
