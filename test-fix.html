<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Placement Test - MinecraftCAD</title>
    <style>
        body { margin: 0; padding: 20px; font-family: monospace; }
        canvas { border: 2px solid #333; cursor: crosshair; }
        .debug { background: #f0f0f0; padding: 10px; margin: 10px 0; }
        .controls { margin: 10px 0; }
        button { margin: 5px; padding: 5px 10px; }
    </style>
</head>
<body>
    <h1>Block Placement Test</h1>
    <p>This tests that blocks place exactly where you click, even after panning and zooming.</p>
    
    <div class="controls">
        <button id="reset-camera">Reset Camera</button>
        <button id="pan-right">Pan Right</button>
        <button id="zoom-in">Zoom In</button>
        <button id="zoom-out">Zoom Out</button>
        <button id="clear-blocks">Clear All</button>
    </div>
    
    <canvas id="test-canvas" width="800" height="600"></canvas>
    
    <div class="debug">
        <h3>Status</h3>
        <div>Mouse: <span id="mouse-pos">-</span></div>
        <div>World: <span id="world-pos">-</span></div>
        <div>Grid: <span id="grid-pos">-</span></div>
        <div>Camera: <span id="camera-info">-</span></div>
        <div>Blocks placed: <span id="block-count">0</span></div>
    </div>
    
    <div class="debug">
        <h3>Test Instructions</h3>
        <ol>
            <li>Click to place a block at cursor position</li>
            <li>Pan the view using "Pan Right" button</li>
            <li>Click again - block should place exactly where cursor is</li>
            <li>Zoom in/out and test again</li>
            <li>If blocks don't place under cursor, the bug is still present</li>
        </ol>
    </div>

    <script type="module">
        import { CameraController } from './src/input/CameraController.js';
        import { TopViewRenderer } from './src/rendering/TopViewRenderer.js';
        
        class BlockPlacementTest {
            constructor() {
                this.canvas = document.getElementById('test-canvas');
                this.renderer = new TopViewRenderer(this.canvas);
                this.camera = new CameraController();
                this.blocks = new Map(); // Store placed blocks
                this.blockCount = 0;
                
                this.init();
            }
            
            init() {
                // Initialize camera
                const rect = this.canvas.getBoundingClientRect();
                this.camera.setViewport(0, 0, rect.width, rect.height);
                this.camera.setActiveView('top');
                
                // Setup event listeners
                this.setupEventListeners();
                
                // Initial render
                this.render();
                
                console.log('Block placement test initialized');
                console.log('Camera state:', this.camera.getCurrentCamera());
            }
            
            setupEventListeners() {
                // Click to place blocks
                this.canvas.addEventListener('click', (event) => {
                    this.handleClick(event);
                });
                
                // Mouse move for debug
                this.canvas.addEventListener('mousemove', (event) => {
                    this.updateDebugInfo(event);
                });
                
                // Controls
                document.getElementById('reset-camera').addEventListener('click', () => {
                    this.camera.resetView('top');
                    this.render();
                    this.updateCameraInfo();
                });
                
                document.getElementById('pan-right').addEventListener('click', () => {
                    this.camera.pan(-100, 0, 'top'); // Pan right (negative X)
                    this.render();
                    this.updateCameraInfo();
                });
                
                document.getElementById('zoom-in').addEventListener('click', () => {
                    const center = this.canvas.width / 2;
                    this.camera.zoom(1.5, center, center, 'top');
                    this.render();
                    this.updateCameraInfo();
                });
                
                document.getElementById('zoom-out').addEventListener('click', () => {
                    const center = this.canvas.width / 2;
                    this.camera.zoom(0.67, center, center, 'top');
                    this.render();
                    this.updateCameraInfo();
                });
                
                document.getElementById('clear-blocks').addEventListener('click', () => {
                    this.blocks.clear();
                    this.blockCount = 0;
                    this.render();
                    this.updateBlockCount();
                });
            }
            
            handleClick(event) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = event.clientX - rect.left;
                const screenY = event.clientY - rect.top;
                
                // Use camera controller for coordinate conversion
                const worldPos = this.camera.screenToWorld(screenX, screenY);
                const blockSize = 20;
                const gridPos = {
                    x: Math.floor(worldPos.x / blockSize),
                    y: Math.floor(worldPos.y / blockSize)
                };
                
                // Place block
                const key = `${gridPos.x},${gridPos.y}`;
                this.blocks.set(key, {
                    x: gridPos.x,
                    y: gridPos.y,
                    type: 'blockA'
                });
                
                this.blockCount++;
                this.render();
                this.updateBlockCount();
                
                console.log('Block placed:', {
                    screen: { x: screenX, y: screenY },
                    world: worldPos,
                    grid: gridPos,
                    camera: this.camera.getCurrentCamera()
                });
            }
            
            render() {
                const cameraState = this.camera.getCurrentCamera();
                
                // Create mock block data
                const blockData = {
                    getBlocksAtLevel: (level) => Array.from(this.blocks.values())
                };
                
                // Render
                this.renderer.render(blockData, cameraState, 0);
                
                // Draw cursor preview (red dot at mouse position)
                this.drawCursorPreview();
            }
            
            drawCursorPreview() {
                // This would show where the next block would be placed
                // For now, we'll rely on the hover effect
            }
            
            updateDebugInfo(event) {
                const rect = this.canvas.getBoundingClientRect();
                const screenX = event.clientX - rect.left;
                const screenY = event.clientY - rect.top;
                const worldPos = this.camera.screenToWorld(screenX, screenY);
                const blockSize = 20;
                const gridPos = {
                    x: Math.floor(worldPos.x / blockSize),
                    y: Math.floor(worldPos.y / blockSize)
                };
                
                document.getElementById('mouse-pos').textContent = `${screenX.toFixed(0)}, ${screenY.toFixed(0)}`;
                document.getElementById('world-pos').textContent = `${worldPos.x.toFixed(1)}, ${worldPos.y.toFixed(1)}`;
                document.getElementById('grid-pos').textContent = `${gridPos.x}, ${gridPos.y}`;
                
                this.updateCameraInfo();
            }
            
            updateCameraInfo() {
                const camera = this.camera.getCurrentCamera();
                document.getElementById('camera-info').textContent = 
                    `Offset: ${camera.offsetX.toFixed(0)}, ${camera.offsetY.toFixed(0)} | Zoom: ${camera.zoom.toFixed(2)}`;
            }
            
            updateBlockCount() {
                document.getElementById('block-count').textContent = this.blockCount;
            }
        }
        
        // Start test when page loads
        window.addEventListener('load', () => {
            new BlockPlacementTest();
        });
    </script>
</body>
</html>