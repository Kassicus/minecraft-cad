<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Coordinate Debug Test</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1e3a5f; color: #64b5f6; }
        .test-section { background: rgba(255,255,255,0.05); border: 1px solid #64b5f6; border-radius: 8px; padding: 20px; margin: 20px 0; }
        canvas { border: 2px solid #64b5f6; background: #0d1b2a; cursor: crosshair; }
        .status { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin: 10px 0; }
        button { background: #1e3a5f; color: #64b5f6; border: 1px solid #64b5f6; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #2d5a8f; }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Coordinate Debug Test</h1>
        
        <div class="test-section">
            <h3>Test Instructions</h3>
            <p>This test verifies coordinate transformations and zoom functionality:</p>
            <ul>
                <li>Click on the canvas to place blocks</li>
                <li>Use mouse wheel to zoom in/out</li>
                <li>Check that blocks can be placed in negative coordinates</li>
                <li>Verify zoom changes are visible</li>
            </ul>
            <button onclick="testNegativeCoords()">Test Negative Coordinates</button>
            <button onclick="testZoom()">Test Zoom</button>
            <button onclick="clearBlocks()">Clear All Blocks</button>
            <button onclick="resetView()">Reset View</button>
        </div>

        <div class="test-section">
            <canvas id="test-canvas" class="test-canvas" width="600" height="400"></canvas>
        </div>

        <div class="test-section">
            <h3>Status</h3>
            <div class="status">
                <div>Mouse: <span id="mouse-pos">(0, 0)</span></div>
                <div>World: <span id="world-pos">(0, 0)</span></div>
                <div>Grid: <span id="grid-pos">(0, 0)</span></div>
                <div>Blocks: <span id="block-count">0</span></div>
                <div>Zoom: <span id="zoom-level">3.0</span></div>
                <div>Camera Offset: <span id="camera-offset">(300, 200)</span></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { coordinateSystem } from './src/utils/CoordinateSystem.js';
        import { BlockDataManager } from './src/core/BlockDataManager.js';
        import { HatchPatternManager } from './src/rendering/HatchPatternManager.js';

        class CoordinateDebugTest {
            constructor() {
                this.canvas = document.getElementById('test-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Initialize systems
                this.blockDataManager = new BlockDataManager();
                this.hatchPatterns = new HatchPatternManager();
                
                // Camera state - centered at (0,0) with closer zoom
                this.camera = { 
                    offsetX: 300, 
                    offsetY: 200, 
                    zoom: 3.0 
                };
                
                // Mouse state
                this.mouse = { x: 0, y: 0 };
                
                this.setupEventListeners();
                this.render();
                this.updateStatus();
                
                console.log('CoordinateDebugTest initialized with camera:', this.camera);
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
            }

            handleMouseDown(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = event.clientX - rect.left;
                this.mouse.y = event.clientY - rect.top;
                
                // Place block at mouse position
                this.placeBlock();
                this.updateStatus();
            }

            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = event.clientX - rect.left;
                this.mouse.y = event.clientY - rect.top;
                this.updateStatus();
            }

            handleWheel(event) {
                event.preventDefault();
                console.log('Wheel event:', event.deltaY);
                
                const delta = event.deltaY > 0 ? 0.9 : 1.1;
                this.zoom(delta);
                this.render();
                this.updateStatus();
            }

            placeBlock() {
                // Convert screen to world coordinates
                const worldPos = coordinateSystem.screenToWorld(this.mouse.x, this.mouse.y, this.camera);
                
                // Convert world to grid coordinates
                const gridPos = coordinateSystem.worldToGrid(worldPos.x, worldPos.y);
                
                // Place block (alternate between block types)
                const blockTypes = ['blockA', 'blockB', 'blockC', 'blockD', 'blockE'];
                const blockType = blockTypes[Math.floor(Math.random() * blockTypes.length)];
                
                console.log(`Placing block: screen(${this.mouse.x}, ${this.mouse.y}) -> world(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}) -> grid(${gridPos.x}, ${gridPos.y})`);
                
                const success = this.blockDataManager.setBlock(gridPos.x, gridPos.y, 0, blockType);
                
                if (success) {
                    console.log(`Placed ${blockType} at (${gridPos.x}, ${gridPos.y})`);
                    this.render();
                } else {
                    console.error(`Failed to place block at (${gridPos.x}, ${gridPos.y})`);
                }
            }

            zoom(factor) {
                const oldZoom = this.camera.zoom;
                this.camera.zoom = Math.max(0.1, Math.min(10.0, oldZoom * factor));
                
                console.log(`Zoom changed: ${oldZoom.toFixed(2)} -> ${this.camera.zoom.toFixed(2)} (factor: ${factor})`);
                
                // Keep center point stable
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const worldPoint = coordinateSystem.screenToWorld(centerX, centerY, this.camera);
                
                const newScreenPoint = coordinateSystem.worldToScreen(worldPoint.x, worldPoint.y, this.camera);
                this.camera.offsetX += centerX - newScreenPoint.x;
                this.camera.offsetY += centerY - newScreenPoint.y;
                
                console.log(`Camera offset updated: (${this.camera.offsetX.toFixed(2)}, ${this.camera.offsetY.toFixed(2)})`);
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#0d1b2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                coordinateSystem.drawGrid(
                    this.ctx,
                    this.camera,
                    this.canvas.width,
                    this.canvas.height,
                    {
                        showGrid: true,
                        showMajorGrid: true,
                        gridColor: 'rgba(100, 181, 246, 0.1)',
                        majorGridColor: 'rgba(100, 181, 246, 0.3)',
                        majorGridInterval: 10,
                        minGridSize: 2
                    }
                );
                
                // Draw blocks
                this.drawBlocks();
                
                // Draw cursor
                this.drawCursor();
                
                // Draw coordinate axes
                this.drawAxes();
            }

            drawBlocks() {
                const blocks = this.blockDataManager.getAllBlocks();
                const blockSize = 20 * this.camera.zoom;
                
                for (const block of blocks) {
                    const worldPos = coordinateSystem.gridToWorld(block.x, block.y);
                    const screenPos = coordinateSystem.worldToScreen(worldPos.x, worldPos.y, this.camera);
                    
                    // Draw block with pattern
                    this.hatchPatterns.fillRectWithPattern(
                        this.ctx,
                        screenPos.x - blockSize/2,
                        screenPos.y - blockSize/2,
                        blockSize,
                        blockSize,
                        block.type,
                        1.0,
                        1.0
                    );
                    
                    // Draw border
                    if (blockSize > 4) {
                        this.ctx.strokeStyle = '#64b5f6';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(
                            screenPos.x - blockSize/2,
                            screenPos.y - blockSize/2,
                            blockSize,
                            blockSize
                        );
                    }
                    
                    // Draw coordinates
                    if (blockSize > 15) {
                        this.ctx.fillStyle = '#64b5f6';
                        this.ctx.font = '10px monospace';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText(`(${block.x},${block.y})`, screenPos.x, screenPos.y + blockSize/2 + 12);
                    }
                }
            }

            drawCursor() {
                this.ctx.save();
                this.ctx.strokeStyle = '#64b5f6';
                this.ctx.lineWidth = 2;
                
                const size = 8;
                this.ctx.beginPath();
                this.ctx.moveTo(this.mouse.x - size, this.mouse.y);
                this.ctx.lineTo(this.mouse.x + size, this.mouse.y);
                this.ctx.moveTo(this.mouse.x, this.mouse.y - size);
                this.ctx.lineTo(this.mouse.x, this.mouse.y + size);
                this.ctx.stroke();
                
                this.ctx.restore();
            }

            drawAxes() {
                // Draw X and Y axes at world origin (0,0)
                const originScreen = coordinateSystem.worldToScreen(0, 0, this.camera);
                
                this.ctx.save();
                this.ctx.strokeStyle = '#ff4444';
                this.ctx.lineWidth = 2;
                
                // X axis (red)
                this.ctx.beginPath();
                this.ctx.moveTo(originScreen.x, 0);
                this.ctx.lineTo(originScreen.x, this.canvas.height);
                this.ctx.stroke();
                
                // Y axis (green)
                this.ctx.strokeStyle = '#44ff44';
                this.ctx.beginPath();
                this.ctx.moveTo(0, originScreen.y);
                this.ctx.lineTo(this.canvas.width, originScreen.y);
                this.ctx.stroke();
                
                // Origin marker
                this.ctx.fillStyle = '#ffff44';
                this.ctx.beginPath();
                this.ctx.arc(originScreen.x, originScreen.y, 4, 0, 2 * Math.PI);
                this.ctx.fill();
                
                this.ctx.restore();
            }

            updateStatus() {
                const worldPos = coordinateSystem.screenToWorld(this.mouse.x, this.mouse.y, this.camera);
                const gridPos = coordinateSystem.worldToGrid(worldPos.x, worldPos.y);
                const stats = this.blockDataManager.getStats();
                
                document.getElementById('mouse-pos').textContent = `(${this.mouse.x.toFixed(0)}, ${this.mouse.y.toFixed(0)})`;
                document.getElementById('world-pos').textContent = `(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})`;
                document.getElementById('grid-pos').textContent = `(${gridPos.x}, ${gridPos.y})`;
                document.getElementById('block-count').textContent = stats.totalBlocks;
                document.getElementById('zoom-level').textContent = this.camera.zoom.toFixed(2);
                document.getElementById('camera-offset').textContent = `(${this.camera.offsetX.toFixed(0)}, ${this.camera.offsetY.toFixed(0)})`;
            }

            clearBlocks() {
                this.blockDataManager.clear();
                this.render();
                this.updateStatus();
            }

            resetView() {
                this.camera.offsetX = this.canvas.width / 2;
                this.camera.offsetY = this.canvas.height / 2;
                this.camera.zoom = 3.0;
                this.render();
                this.updateStatus();
                console.log('View reset to:', this.camera);
            }

            testNegativeCoords() {
                console.log('=== Testing Negative Coordinates ===');
                
                // Test placing blocks at negative coordinates
                const testPositions = [
                    [-5, -5], [-3, -2], [-1, -1], [0, 0], [1, 1], [3, 2], [5, 5]
                ];
                
                testPositions.forEach(([x, y], index) => {
                    const blockType = `block${String.fromCharCode(65 + (index % 5))}`;
                    const success = this.blockDataManager.setBlock(x, y, 0, blockType);
                    console.log(`Test placement at (${x}, ${y}): ${success ? 'SUCCESS' : 'FAILED'}`);
                });
                
                this.render();
                this.updateStatus();
                console.log('=== Negative Coordinate Test Complete ===');
            }

            testZoom() {
                console.log('=== Testing Zoom ===');
                console.log('Current zoom:', this.camera.zoom);
                
                // Test zoom in
                this.zoom(1.5);
                console.log('After zoom in:', this.camera.zoom);
                
                // Test zoom out
                this.zoom(0.8);
                console.log('After zoom out:', this.camera.zoom);
                
                this.render();
                this.updateStatus();
                console.log('=== Zoom Test Complete ===');
            }
        }

        // Initialize test
        let testInstance = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            testInstance = new CoordinateDebugTest();
            
            // Make functions available globally
            window.clearBlocks = () => testInstance.clearBlocks();
            window.resetView = () => testInstance.resetView();
            window.testNegativeCoords = () => testInstance.testNegativeCoords();
            window.testZoom = () => testInstance.testZoom();
        });
    </script>
</body>
</html>
