<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Block Placement Test - MinecraftCAD</title>
    <style>
        body {
            font-family: monospace;
            margin: 20px;
            background: #1e3a5f;
            color: #64b5f6;
        }
        .test-container {
            max-width: 1200px;
            margin: 0 auto;
        }
        .test-section {
            background: rgba(255,255,255,0.05);
            border: 1px solid #64b5f6;
            border-radius: 8px;
            padding: 20px;
            margin: 20px 0;
        }
        .test-canvas {
            border: 2px solid #64b5f6;
            background: #0d1b2a;
            cursor: crosshair;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            flex-wrap: wrap;
        }
        button {
            background: #1e3a5f;
            color: #64b5f6;
            border: 1px solid #64b5f6;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #2d5a8f;
        }
        button.active {
            background: #64b5f6;
            color: #0d1b2a;
        }
        .status {
            background: rgba(0,0,0,0.3);
            padding: 10px;
            border-radius: 4px;
            margin: 10px 0;
        }
        .block-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin: 10px 0;
        }
        .block-item {
            background: rgba(255,255,255,0.1);
            border: 1px solid #64b5f6;
            padding: 10px;
            text-align: center;
            cursor: pointer;
            border-radius: 4px;
        }
        .block-item.active {
            background: #64b5f6;
            color: #0d1b2a;
        }
        .block-pattern {
            width: 40px;
            height: 20px;
            margin: 0 auto 5px;
            border: 1px solid #64b5f6;
        }
        .pattern-solid { background: #666; }
        .pattern-diagonal { 
            background: repeating-linear-gradient(45deg, #888, #888 2px, transparent 2px, transparent 8px);
        }
        .pattern-cross { 
            background: 
                repeating-linear-gradient(45deg, #444, #444 2px, transparent 2px, transparent 8px),
                repeating-linear-gradient(-45deg, #444, #444 2px, transparent 2px, transparent 8px);
        }
        .pattern-dots { 
            background-image: radial-gradient(circle, #555 1px, transparent 1px);
            background-size: 8px 8px;
        }
        .pattern-brick { 
            background: 
                linear-gradient(90deg, #777 50%, transparent 50%),
                linear-gradient(0deg, #777 50%, transparent 50%);
            background-size: 8px 4px;
        }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Block Placement Test - MinecraftCAD</h1>
        
        <div class="test-section">
            <h3>Test Instructions</h3>
            <p>This test verifies that block placement works correctly with coordinate transformation:</p>
            <ul>
                <li>Click on the canvas to place blocks</li>
                <li>Use mouse wheel to zoom in/out</li>
                <li>Select different block types from the grid below</li>
                <li>Check that blocks appear at the correct grid positions</li>
                <li>Verify coordinate display shows correct values</li>
            </ul>
        </div>

        <div class="test-section">
            <h3>Block Type Selection</h3>
            <div class="block-grid">
                <div class="block-item active" data-block-type="blockA">
                    <div class="block-pattern pattern-solid"></div>
                    <div>Block A</div>
                </div>
                <div class="block-item" data-block-type="blockB">
                    <div class="block-pattern pattern-diagonal"></div>
                    <div>Block B</div>
                </div>
                <div class="block-item" data-block-type="blockC">
                    <div class="block-pattern pattern-cross"></div>
                    <div>Block C</div>
                </div>
                <div class="block-item" data-block-type="blockD">
                    <div class="block-pattern pattern-dots"></div>
                    <div>Block D</div>
                </div>
                <div class="block-item" data-block-type="blockE">
                    <div class="block-pattern pattern-brick"></div>
                    <div>Block E</div>
                </div>
            </div>
        </div>

        <div class="test-section">
            <h3>Canvas Test Area</h3>
            <canvas id="test-canvas" class="test-canvas" width="800" height="600"></canvas>
            
            <div class="controls">
                <button id="clear-btn">Clear All Blocks</button>
                <button id="reset-view-btn">Reset View</button>
                <button id="test-coords-btn">Test Coordinates</button>
            </div>
        </div>

        <div class="test-section">
            <h3>Status Information</h3>
            <div class="status">
                <div>Mouse Position: <span id="mouse-pos">(0, 0)</span></div>
                <div>World Coordinates: <span id="world-pos">(0, 0)</span></div>
                <div>Grid Coordinates: <span id="grid-pos">(0, 0)</span></div>
                <div>Current Block Type: <span id="current-block">Block A</span></div>
                <div>Total Blocks: <span id="total-blocks">0</span></div>
                <div>Camera Zoom: <span id="camera-zoom">1.0</span></div>
                <div>Camera Offset: <span id="camera-offset">(0, 0)</span></div>
            </div>
        </div>

        <div class="test-section">
            <h3>Debug Information</h3>
            <div class="status">
                <div>Coordinate System Block Size: <span id="block-size">20</span></div>
                <div>Canvas Size: <span id="canvas-size">800x600</span></div>
                <div>Viewport Bounds: <span id="viewport-bounds">(0, 0, 800, 600)</span></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { coordinateSystem } from './src/utils/CoordinateSystem.js';
        import { BlockDataManager } from './src/core/BlockDataManager.js';
        import { HatchPatternManager } from './src/rendering/HatchPatternManager.js';

        class BlockPlacementTest {
            constructor() {
                this.canvas = document.getElementById('test-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Initialize systems
                this.blockDataManager = new BlockDataManager();
                this.hatchPatterns = new HatchPatternManager();
                
                // Camera state (simplified) - centered at (0,0) with closer zoom
                this.camera = {
                    offsetX: 400, // Center of canvas
                    offsetY: 300,
                    zoom: 3.0
                };
                
                // Current block type
                this.currentBlockType = 'blockA';
                
                // Mouse state
                this.mouse = { x: 0, y: 0, isDown: false };
                
                this.setupEventListeners();
                this.setupBlockSelection();
                this.render();
            }

            setupEventListeners() {
                // Mouse events
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this));
                
                // Control buttons
                document.getElementById('clear-btn').addEventListener('click', () => {
                    this.blockDataManager.clear();
                    this.render();
                    this.updateStatus();
                });
                
                document.getElementById('reset-view-btn').addEventListener('click', () => {
                    this.resetView();
                });
                
                document.getElementById('test-coords-btn').addEventListener('click', () => {
                    this.testCoordinateTransformation();
                });
            }

            setupBlockSelection() {
                const blockItems = document.querySelectorAll('.block-item');
                blockItems.forEach(item => {
                    item.addEventListener('click', () => {
                        // Remove active class from all items
                        blockItems.forEach(i => i.classList.remove('active'));
                        
                        // Add active class to clicked item
                        item.classList.add('active');
                        
                        // Update current block type
                        this.currentBlockType = item.dataset.blockType;
                        this.updateStatus();
                    });
                });
            }

            handleMouseDown(event) {
                this.mouse.isDown = true;
                this.handleMouseMove(event);
            }

            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = event.clientX - rect.left;
                this.mouse.y = event.clientY - rect.top;
                
                this.updateStatus();
                
                if (this.mouse.isDown) {
                    this.placeBlockAtMouse();
                }
            }

            handleMouseUp(event) {
                this.mouse.isDown = false;
            }

            handleWheel(event) {
                event.preventDefault();
                
                const delta = event.deltaY > 0 ? 0.9 : 1.1;
                const centerX = event.clientX - this.canvas.getBoundingClientRect().left;
                const centerY = event.clientY - this.canvas.getBoundingClientRect().top;
                
                this.zoom(delta, centerX, centerY);
                this.render();
                this.updateStatus();
            }

            placeBlockAtMouse() {
                // Convert screen coordinates to world coordinates
                const worldPos = coordinateSystem.screenToWorld(this.mouse.x, this.mouse.y, this.camera);
                
                // Convert world coordinates to grid coordinates
                const gridPos = coordinateSystem.worldToGrid(worldPos.x, worldPos.y);
                
                // Place block at grid position
                const success = this.blockDataManager.setBlock(gridPos.x, gridPos.y, 0, this.currentBlockType);
                
                if (success) {
                    console.log(`Placed ${this.currentBlockType} at grid (${gridPos.x}, ${gridPos.y})`);
                    this.render();
                    this.updateStatus();
                }
            }

            zoom(factor, centerX, centerY) {
                const oldZoom = this.camera.zoom;
                const newZoom = Math.max(0.1, Math.min(10.0, oldZoom * factor));
                
                if (newZoom !== oldZoom) {
                    // Calculate world point at center
                    const worldPoint = coordinateSystem.screenToWorld(centerX, centerY, this.camera);
                    
                    // Update zoom
                    this.camera.zoom = newZoom;
                    
                    // Adjust offset to keep world point at same screen position
                    const newScreenPoint = coordinateSystem.worldToScreen(worldPoint.x, worldPoint.y, this.camera);
                    this.camera.offsetX += centerX - newScreenPoint.x;
                    this.camera.offsetY += centerY - newScreenPoint.y;
                }
            }

            resetView() {
                this.camera.offsetX = this.canvas.width / 2;
                this.camera.offsetY = this.canvas.height / 2;
                this.camera.zoom = 3.0; // Start with closer zoom
                this.render();
                this.updateStatus();
            }

            testCoordinateTransformation() {
                console.log('=== Coordinate Transformation Test ===');
                
                // Test screen to world
                const screenPos = { x: 400, y: 300 };
                const worldPos = coordinateSystem.screenToWorld(screenPos.x, screenPos.y, this.camera);
                console.log(`Screen (${screenPos.x}, ${screenPos.y}) -> World (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})`);
                
                // Test world to grid
                const gridPos = coordinateSystem.worldToGrid(worldPos.x, worldPos.y);
                console.log(`World (${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)}) -> Grid (${gridPos.x}, ${gridPos.y})`);
                
                // Test grid to world
                const worldPos2 = coordinateSystem.gridToWorld(gridPos.x, gridPos.y);
                console.log(`Grid (${gridPos.x}, ${gridPos.y}) -> World (${worldPos2.x.toFixed(2)}, ${worldPos2.y.toFixed(2)})`);
                
                // Test world to screen
                const screenPos2 = coordinateSystem.worldToScreen(worldPos2.x, worldPos2.y, this.camera);
                console.log(`World (${worldPos2.x.toFixed(2)}, ${worldPos2.y.toFixed(2)}) -> Screen (${screenPos2.x.toFixed(2)}, ${screenPos2.y.toFixed(2)})`);
                
                console.log('=== End Test ===');
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#0d1b2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                coordinateSystem.drawGrid(
                    this.ctx,
                    this.camera,
                    this.canvas.width,
                    this.canvas.height,
                    {
                        showGrid: true,
                        showMajorGrid: true,
                        gridColor: 'rgba(100, 181, 246, 0.1)',
                        majorGridColor: 'rgba(100, 181, 246, 0.3)',
                        majorGridInterval: 10,
                        minGridSize: 2
                    }
                );
                
                // Draw blocks
                this.drawBlocks();
                
                // Draw cursor indicator
                this.drawCursorIndicator();
            }

            drawBlocks() {
                const blocks = this.blockDataManager.getAllBlocks();
                const blockSize = 20 * this.camera.zoom;
                
                for (const block of blocks) {
                    // Convert grid coordinates to screen coordinates
                    const worldPos = coordinateSystem.gridToWorld(block.x, block.y);
                    const screenPos = coordinateSystem.worldToScreen(worldPos.x, worldPos.y, this.camera);
                    
                    // Draw block with pattern
                    this.hatchPatterns.fillRectWithPattern(
                        this.ctx,
                        screenPos.x - blockSize/2,
                        screenPos.y - blockSize/2,
                        blockSize,
                        blockSize,
                        block.type,
                        1.0,
                        1.0
                    );
                    
                    // Draw border
                    if (blockSize > 4) {
                        this.ctx.strokeStyle = '#64b5f6';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(
                            screenPos.x - blockSize/2,
                            screenPos.y - blockSize/2,
                            blockSize,
                            blockSize
                        );
                    }
                }
            }

            drawCursorIndicator() {
                // Draw a small crosshair at mouse position
                this.ctx.save();
                this.ctx.strokeStyle = '#64b5f6';
                this.ctx.lineWidth = 2;
                
                const size = 10;
                this.ctx.beginPath();
                this.ctx.moveTo(this.mouse.x - size, this.mouse.y);
                this.ctx.lineTo(this.mouse.x + size, this.mouse.y);
                this.ctx.moveTo(this.mouse.x, this.mouse.y - size);
                this.ctx.lineTo(this.mouse.x, this.mouse.y + size);
                this.ctx.stroke();
                
                this.ctx.restore();
            }

            updateStatus() {
                // Update mouse position
                document.getElementById('mouse-pos').textContent = `(${this.mouse.x.toFixed(0)}, ${this.mouse.y.toFixed(0)})`;
                
                // Update world coordinates
                const worldPos = coordinateSystem.screenToWorld(this.mouse.x, this.mouse.y, this.camera);
                document.getElementById('world-pos').textContent = `(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})`;
                
                // Update grid coordinates
                const gridPos = coordinateSystem.worldToGrid(worldPos.x, worldPos.y);
                document.getElementById('grid-pos').textContent = `(${gridPos.x}, ${gridPos.y})`;
                
                // Update current block type
                document.getElementById('current-block').textContent = this.currentBlockType;
                
                // Update total blocks
                const stats = this.blockDataManager.getStats();
                document.getElementById('total-blocks').textContent = stats.totalBlocks;
                
                // Update camera info
                document.getElementById('camera-zoom').textContent = this.camera.zoom.toFixed(2);
                document.getElementById('camera-offset').textContent = `(${this.camera.offsetX.toFixed(0)}, ${this.camera.offsetY.toFixed(0)})`;
                
                // Update debug info
                document.getElementById('block-size').textContent = coordinateSystem.getBlockSize();
                document.getElementById('canvas-size').textContent = `${this.canvas.width}x${this.canvas.height}`;
                document.getElementById('viewport-bounds').textContent = `(0, 0, ${this.canvas.width}, ${this.canvas.height})`;
            }
        }

        // Initialize test when page loads
        document.addEventListener('DOMContentLoaded', () => {
            new BlockPlacementTest();
        });
    </script>
</body>
</html>
