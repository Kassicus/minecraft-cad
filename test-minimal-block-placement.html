<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Minimal Block Placement Test</title>
    <style>
        body { font-family: monospace; margin: 20px; background: #1e3a5f; color: #64b5f6; }
        .test-container { max-width: 800px; margin: 0 auto; }
        .test-section { background: rgba(255,255,255,0.05); border: 1px solid #64b5f6; border-radius: 8px; padding: 20px; margin: 20px 0; }
        .test-canvas { border: 2px solid #64b5f6; background: #0d1b2a; cursor: crosshair; }
        .status { background: rgba(0,0,0,0.3); padding: 10px; border-radius: 4px; margin: 10px 0; }
        button { background: #1e3a5f; color: #64b5f6; border: 1px solid #64b5f6; padding: 8px 16px; border-radius: 4px; cursor: pointer; margin: 5px; }
        button:hover { background: #2d5a8f; }
    </style>
</head>
<body>
    <div class="test-container">
        <h1>Minimal Block Placement Test</h1>
        
        <div class="test-section">
            <h3>Test Instructions</h3>
            <p>Click on the canvas to place blocks. Use mouse wheel to zoom.</p>
            <button onclick="clearBlocks()">Clear All Blocks</button>
            <button onclick="resetView()">Reset View</button>
            <button onclick="testPlacement()">Test Placement</button>
        </div>

        <div class="test-section">
            <canvas id="test-canvas" class="test-canvas" width="600" height="400"></canvas>
        </div>

        <div class="test-section">
            <h3>Status</h3>
            <div class="status">
                <div>Mouse: <span id="mouse-pos">(0, 0)</span></div>
                <div>World: <span id="world-pos">(0, 0)</span></div>
                <div>Grid: <span id="grid-pos">(0, 0)</span></div>
                <div>Blocks: <span id="block-count">0</span></div>
                <div>Zoom: <span id="zoom-level">1.0</span></div>
            </div>
        </div>
    </div>

    <script type="module">
        import { coordinateSystem } from './src/utils/CoordinateSystem.js';
        import { BlockDataManager } from './src/core/BlockDataManager.js';
        import { HatchPatternManager } from './src/rendering/HatchPatternManager.js';

        class MinimalBlockTest {
            constructor() {
                this.canvas = document.getElementById('test-canvas');
                this.ctx = this.canvas.getContext('2d');
                
                // Initialize systems
                this.blockDataManager = new BlockDataManager();
                this.hatchPatterns = new HatchPatternManager();
                
                // Simple camera - centered at (0,0) with closer zoom
                this.camera = { offsetX: 300, offsetY: 200, zoom: 3.0 };
                
                // Mouse state
                this.mouse = { x: 0, y: 0 };
                
                this.setupEventListeners();
                this.render();
                this.updateStatus();
            }

            setupEventListeners() {
                this.canvas.addEventListener('mousedown', (e) => this.handleMouseDown(e));
                this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
                this.canvas.addEventListener('wheel', (e) => this.handleWheel(e));
            }

            handleMouseDown(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = event.clientX - rect.left;
                this.mouse.y = event.clientY - rect.top;
                
                // Place block at mouse position
                this.placeBlock();
                this.updateStatus();
            }

            handleMouseMove(event) {
                const rect = this.canvas.getBoundingClientRect();
                this.mouse.x = event.clientX - rect.left;
                this.mouse.y = event.clientY - rect.top;
                this.updateStatus();
            }

            handleWheel(event) {
                event.preventDefault();
                const delta = event.deltaY > 0 ? 0.9 : 1.1;
                this.zoom(delta);
                this.render();
                this.updateStatus();
            }

            placeBlock() {
                // Convert screen to world coordinates
                const worldPos = coordinateSystem.screenToWorld(this.mouse.x, this.mouse.y, this.camera);
                
                // Convert world to grid coordinates
                const gridPos = coordinateSystem.worldToGrid(worldPos.x, worldPos.y);
                
                // Place block (alternate between block types)
                const blockTypes = ['blockA', 'blockB', 'blockC', 'blockD', 'blockE'];
                const blockType = blockTypes[Math.floor(Math.random() * blockTypes.length)];
                
                const success = this.blockDataManager.setBlock(gridPos.x, gridPos.y, 0, blockType);
                
                if (success) {
                    console.log(`Placed ${blockType} at (${gridPos.x}, ${gridPos.y})`);
                    this.render();
                }
            }

            zoom(factor) {
                const oldZoom = this.camera.zoom;
                this.camera.zoom = Math.max(0.1, Math.min(5.0, oldZoom * factor));
                
                // Keep center point stable
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const worldPoint = coordinateSystem.screenToWorld(centerX, centerY, this.camera);
                
                const newScreenPoint = coordinateSystem.worldToScreen(worldPoint.x, worldPoint.y, this.camera);
                this.camera.offsetX += centerX - newScreenPoint.x;
                this.camera.offsetY += centerY - newScreenPoint.y;
            }

            render() {
                // Clear canvas
                this.ctx.fillStyle = '#0d1b2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Draw grid
                coordinateSystem.drawGrid(
                    this.ctx,
                    this.camera,
                    this.canvas.width,
                    this.canvas.height,
                    {
                        showGrid: true,
                        showMajorGrid: true,
                        gridColor: 'rgba(100, 181, 246, 0.1)',
                        majorGridColor: 'rgba(100, 181, 246, 0.3)',
                        majorGridInterval: 10,
                        minGridSize: 2
                    }
                );
                
                // Draw blocks
                this.drawBlocks();
                
                // Draw cursor
                this.drawCursor();
            }

            drawBlocks() {
                const blocks = this.blockDataManager.getAllBlocks();
                const blockSize = 20 * this.camera.zoom;
                
                for (const block of blocks) {
                    const worldPos = coordinateSystem.gridToWorld(block.x, block.y);
                    const screenPos = coordinateSystem.worldToScreen(worldPos.x, worldPos.y, this.camera);
                    
                    // Draw block with pattern
                    this.hatchPatterns.fillRectWithPattern(
                        this.ctx,
                        screenPos.x - blockSize/2,
                        screenPos.y - blockSize/2,
                        blockSize,
                        blockSize,
                        block.type,
                        1.0,
                        1.0
                    );
                    
                    // Draw border
                    if (blockSize > 4) {
                        this.ctx.strokeStyle = '#64b5f6';
                        this.ctx.lineWidth = 1;
                        this.ctx.strokeRect(
                            screenPos.x - blockSize/2,
                            screenPos.y - blockSize/2,
                            blockSize,
                            blockSize
                        );
                    }
                }
            }

            drawCursor() {
                this.ctx.save();
                this.ctx.strokeStyle = '#64b5f6';
                this.ctx.lineWidth = 2;
                
                const size = 8;
                this.ctx.beginPath();
                this.ctx.moveTo(this.mouse.x - size, this.mouse.y);
                this.ctx.lineTo(this.mouse.x + size, this.mouse.y);
                this.ctx.moveTo(this.mouse.x, this.mouse.y - size);
                this.ctx.lineTo(this.mouse.x, this.mouse.y + size);
                this.ctx.stroke();
                
                this.ctx.restore();
            }

            updateStatus() {
                const worldPos = coordinateSystem.screenToWorld(this.mouse.x, this.mouse.y, this.camera);
                const gridPos = coordinateSystem.worldToGrid(worldPos.x, worldPos.y);
                const stats = this.blockDataManager.getStats();
                
                document.getElementById('mouse-pos').textContent = `(${this.mouse.x.toFixed(0)}, ${this.mouse.y.toFixed(0)})`;
                document.getElementById('world-pos').textContent = `(${worldPos.x.toFixed(2)}, ${worldPos.y.toFixed(2)})`;
                document.getElementById('grid-pos').textContent = `(${gridPos.x}, ${gridPos.y})`;
                document.getElementById('block-count').textContent = stats.totalBlocks;
                document.getElementById('zoom-level').textContent = this.camera.zoom.toFixed(2);
            }

            clearBlocks() {
                this.blockDataManager.clear();
                this.render();
                this.updateStatus();
            }

            resetView() {
                this.camera.offsetX = this.canvas.width / 2;
                this.camera.offsetY = this.canvas.height / 2;
                this.camera.zoom = 3.0; // Start with closer zoom
                this.render();
                this.updateStatus();
            }

            testPlacement() {
                console.log('=== Testing Block Placement ===');
                
                // Test placing blocks at specific grid coordinates
                const testPositions = [
                    [0, 0], [1, 0], [2, 0], [0, 1], [1, 1], [2, 1]
                ];
                
                testPositions.forEach(([x, y], index) => {
                    const blockType = `block${String.fromCharCode(65 + (index % 5))}`;
                    const success = this.blockDataManager.setBlock(x, y, 0, blockType);
                    console.log(`Test placement at (${x}, ${y}): ${success ? 'SUCCESS' : 'FAILED'}`);
                });
                
                this.render();
                this.updateStatus();
                console.log('=== Test Complete ===');
            }
        }

        // Initialize test
        let testInstance = null;
        
        document.addEventListener('DOMContentLoaded', () => {
            testInstance = new MinimalBlockTest();
            
            // Make functions available globally
            window.clearBlocks = () => testInstance.clearBlocks();
            window.resetView = () => testInstance.resetView();
            window.testPlacement = () => testInstance.testPlacement();
        });
    </script>
</body>
</html>
